import express from 'express';
import OpenAI from 'openai';
import dotenv from 'dotenv';

dotenv.config();
const router = express.Router();

// --- OpenAI Configuration ---
// Ensure the API key is loaded
if (!process.env.OPENAI_API_KEY) {
  console.error('FATAL ERROR: OPENAI_API_KEY is not set in .env');
  // In a real app, you might exit or have middleware check this
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const model = 'gpt-3.5-turbo';

// --- Helper: Main Generation Function ---
/**
 * A generic helper to call the OpenAI API.
 * @param {string} systemPrompt - The system prompt defining the AI's role.
 * @param {string} userPrompt - The user's specific request.
 * @returns {Promise<{content: string, usage: object}>} - The generated content and token usage.
 */
const getOpenAICompletion = async (systemPrompt, userPrompt) => {
  try {
    const completion = await openai.chat.completions.create({
      model: model,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: 0.7,
    });

    const content = completion.choices[0]?.message?.content?.trim();
    const usage = completion.usage;

    if (!content) {
      throw new Error('No content returned from OpenAI.');
    }
    return { content, usage };
  } catch (error) {
    console.error('OpenAI API call failed:', error);
    throw new Error(`OpenAI API Error: ${error.message}`);
  }
};

// --- Generation Logic Functions (for parallel execution) ---

const generateScript = (inputs) => {
  const { topic, contentType, tone, targetAudience } = inputs;
  const systemPrompt = `You are an expert ${contentType} scriptwriter. Your scripts are engaging, concise, and perfectly suited for the target platform.`;
  const userPrompt = `Generate a complete 30-60 second video script for a ${contentType} about "${topic}".
    - Tone: ${tone}
    - Target Audience: ${targetAudience}
    - Requirements:
      1. Include [PAUSE] markers for comedic or dramatic timing.
      2. Include [VISUAL] markers describing on-screen actions, B-roll, or text overlays.
      3. The script must be engaging from the first second.
    - Format:
      Host: [Dialogue]
      [VISUAL: ... ]
      Host: [Dialogue]
      [PAUSE]`;
  return getOpenAICompletion(systemPrompt, userPrompt);
};

const generateCaption = (inputs) => {
  const { topic, contentType, tone } = inputs;
  const systemPrompt = `You are a social media manager specializing in high-engagement captions.`;
  const userPrompt = `Create a platform-optimized caption for a ${contentType} about "${topic}".
    - Tone: ${tone}
    - Requirements:
      1. 1-3 sentences.
      2. Include relevant emojis.
      3. End with a clear call-to-action (CTA) like "Comment below", "Link in bio", or "Tag a friend".`;
  return getOpenAICompletion(systemPrompt, userPrompt);
};

const generateHashtags = (inputs) => {
  const { topic, contentType, theme } = inputs;
  const systemPrompt = `You are a hashtag research expert. You provide a clean list of hashtags.`;
  const userPrompt = `Generate 15-20 trending and relevant hashtags for a ${contentType} about "${topic}".
    - Theme: ${theme}
    - Requirements:
      1. A mix of popular (1M+ posts) and niche (<100k posts) hashtags.
      2. Relevant to the topic, platform, and theme.
    - Output Format: A single line of space-separated hashtags (e.g., #hashtag1 #hashtag2 #hashtag3).`;
  return getOpenAICompletion(systemPrompt, userPrompt);
};

const generateThumbnailPrompt = (inputs) => {
  const { topic, theme, tone } = inputs;
  const systemPrompt = `You are a creative director who writes prompts for AI image generators like DALL-E and Midjourney.`;
  const userPrompt = `Write a detailed, descriptive prompt for an AI image generator to create a compelling thumbnail for a video about "${topic}".
    - Theme: ${theme}
    - Tone: ${tone}
    - Requirements:
      1. Describe composition, main subject, background, and lighting.
      2. Suggest specific colors and mood.
      3. Be highly visual and descriptive.
    - Example: "A dynamic, high-contrast shot of a software developer...".`;
  return getOpenAICompletion(systemPrompt, userPrompt);
};

const generateAudioSuggestion = (inputs) => {
  const { contentType, theme, tone } = inputs;
  const systemPrompt = `You are a music supervisor for digital content.`;
  const userPrompt = `Suggest audio for a ${contentType} with a ${tone} tone and ${theme} theme.
    - Requirements:
      1. Suggest a music genre (e.g., Lofi Hip-Hop, Epic Orchestral).
      2. Suggest a BPM range (e.g., 80-100 BPM).
      3. Suggest 1-2 specific (royalty-free) track names or artists if possible.
      4. Suggest where to find such audio (e.g., "Find on Epidemic Sound" or "Search for 'Lofi beats' in the YouTube Audio Library").`;
  return getOpenAICompletion(systemPrompt, userPrompt);
};

// --- MAIN ENDPOINT: Generate Complete Content Kit ---
// CRITICAL: Uses Promise.all() for parallel execution
router.post('/complete', async (req, res, next) => {
  const { topic, contentType, tone, targetAudience, theme, userId } = req.body;

  // Basic validation
  if (!topic || !contentType || !tone || !targetAudience || !theme || !userId) {
    return res.status(400).json({ message: 'Missing required fields.' });
  }

  const inputs = { topic, contentType, tone, targetAudience, theme };

  try {
    console.log(`Starting parallel generation for user: ${userId}`);

    // Execute all generation tasks in parallel
    const [
      scriptResult,
      captionResult,
      hashtagsResult,
      thumbnailResult,
      audioResult
    ] = await Promise.all([
      generateScript(inputs),
      generateCaption(inputs),
      generateHashtags(inputs),
      generateThumbnailPrompt(inputs),
      generateAudioSuggestion(inputs)
    ]);

    // Calculate total token usage
    const totalUsage = [scriptResult, captionResult, hashtagsResult, thumbnailResult, audioResult]
      .reduce((acc, result) => {
        if (result && result.usage) {
          acc.completion_tokens += result.usage.completion_tokens || 0;
          acc.prompt_tokens += result.usage.prompt_tokens || 0;
          acc.total_tokens += result.usage.total_tokens || 0;
        }
        return acc;
      }, { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 });

    console.log(`Generation successful. Total tokens: ${totalUsage.total_tokens}`);

    // Send the complete kit
    res.status(200).json({
      success: true,
      data: {
        script: scriptResult.content,
        caption: captionResult.content,
        // Split hashtags into an array for easier frontend use
        hashtags: hashtagsResult.content.split(' ').filter(h => h.startsWith('#')),
        thumbnailPrompt: thumbnailResult.content,
        audioSuggestion: audioResult.content,
      },
      usage: totalUsage
    });

  } catch (error) {
    console.error('Error in /complete endpoint:', error);
    next(error); // Pass to global error handler
  }
});

// --- Individual Endpoints (for regeneration) ---

router.post('/script', async (req, res, next) => {
  try {
    const result = await generateScript(req.body);
    res.status(200).json({ success: true, data: result.content, usage: result.usage });
  } catch (error) {
    next(error);
  }
});

router.post('/caption', async (req, res, next) => {
  try {
    const result = await generateCaption(req.body);
    res.status(200).json({ success: true, data: result.content, usage: result.usage });
  } catch (error) {
    next(error);
  }
});

router.post('/hashtags', async (req, res, next) => {
  try {
    const result = await generateHashtags(req.body);
    res.status(200).json({
      success: true,
      data: result.content.split(' ').filter(h => h.startsWith('#')),
      usage: result.usage
    });
  } catch (error) {
    next(error);
  }
});

router.post('/thumbnail-prompt', async (req, res, next) => {
  try {
    const result = await generateThumbnailPrompt(req.body);
    res.status(200).json({ success: true, data: result.content, usage: result.usage });
  } catch (error) {
    next(error);
  }
});

router.post('/audio-suggestion', async (req, res, next) => {
  try {
    const result = await generateAudioSuggestion(req.body);
    res.status(200).json({ success: true, data: result.content, usage: result.usage });
  } catch (error) {
    next(error);
  }
});

export default router;